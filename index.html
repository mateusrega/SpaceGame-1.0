<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>SpaceGame 1.0</title>
  <style>
    html, body {
      margin: 0; padding: 0; height: 100%; overflow: hidden;
      background: black;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -ms-user-select: none;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      background: black;
    }
    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      color: lime;
      font-family: monospace;
      font-size: 16px;
      background: rgba(0,0,0,0.5);
      padding: 8px;
      border: 1px solid lime;
      border-radius: 6px;
      z-index: 100;
      max-width: 200px;
    }

    /* Container dos botões touch (mantive botões que não são setas) */
    #touch-controls {
      position: fixed;
      bottom: 10px;
      right: 10px;
      display: flex;
      flex-wrap: wrap;
      width: 140px;
      gap: 10px;
      z-index: 100;
    }
    .btn-touch {
      background-color: #222;
      color: lime;
      border: none;
      border-radius: 12px;
      font-weight: bold;
      font-size: 16px;
      width: 60px;
      height: 60px;
      text-align: center;
      line-height: 60px;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      cursor: pointer;
      box-shadow: 0 0 6px lime;
      touch-action: none;
    }
    .btn-touch:active {
      background-color: lime;
      color: black;
      box-shadow: none;
    }

    /* Joystick (substitui as setas) */
    #joystick-area {
      position: fixed;
      left: 12px;
      bottom: 12px;
      width: 160px;
      height: 160px;
      z-index: 110;
      touch-action: none;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
    }
    #joystick-base {
      position: absolute;
      width: 160px;
      height: 160px;
      border-radius: 50%;
      background: rgba(255,255,255,0.03);
      border: 2px solid rgba(255,255,255,0.05);
    }
    #joystick-stick {
      position: absolute;
      width: 68px;
      height: 68px;
      border-radius: 50%;
      background: rgba(255,255,255,0.12);
      transform: translate(0px, 0px);
      /* removed transition to avoid input latency */
      will-change: transform;
      left: 46px;
      top: 46px;
    }
  </style>
</head>
<body>
  <canvas id="canvas" role="img" aria-label="Canvas do jogo"></canvas>

  <div id="hud">
    <div id="velocidade">Velocidade: 0</div>
    <div id="coordX">X: 0</div>
    <div id="coordY">Y: 0</div>
    <div id="turbo"></div>
  </div>

  <!-- JOYSTICK (substitui setas) -->
  <div id="joystick-area" aria-hidden="true">
    <div id="joystick-base"></div>
    <div id="joystick-stick"></div>
  </div>

  <!-- Botões Touch (mantive Turbo, Map, Pause, Reset) -->
  <div id="touch-controls" aria-hidden="false">
    <button id="btnTurbo" class="btn-touch" aria-label="Ativar turbo">TURBO</button>
    <button id="btnMinimap" class="btn-touch" aria-label="Mostrar minimapa">MAP</button>
    <button id="btnPause" class="btn-touch" aria-label="Pausar jogo">PAUSA</button>
    <button id="btnReset" class="btn-touch" aria-label="Resetar posição">RESET</button>
  </div>

<script>
  // Canvas setup with DPR support
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");

  function resizeCanvas() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    // set CSS size (visual) and actual drawing buffer size scaled by dpr
    canvas.style.width = window.innerWidth + "px";
    canvas.style.height = window.innerHeight + "px";
    canvas.width = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    // set transform so drawing coordinates are in CSS pixels
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener("resize", resizeCanvas);
  resizeCanvas();

  // Game state (kept similar to original)
  const worldRadius = 100000;
  const player = { x: 0, y: 0, vx: 0, vy: 0, angle: 0 }; // angle normalized to 0 to start
  let maxSpeed = 50;

  // Mobile-only controls state
  let turboEnabled = false;
  let minimapEnabled = false;
  let paused = false;

  // Buttons
  const btnTurbo = document.getElementById("btnTurbo");
  const btnMinimap = document.getElementById("btnMinimap");
  const btnPause = document.getElementById("btnPause");
  const btnReset = document.getElementById("btnReset");

  function updateButtonLabels(){
    btnTurbo.textContent = turboEnabled ? "TURBO ON" : "TURBO";
    btnMinimap.textContent = minimapEnabled ? "MAP ON" : "MAP";
    btnPause.textContent = paused ? "CONTINUAR" : "PAUSA";
  }

  // Support both touch and pointer/click; preventDefault on touchstart to avoid scrolling/gestures
  function addButtonHandler(el, fn) {
    el.addEventListener('touchstart', (e) => { e.preventDefault(); fn(e); }, {passive:false});
    el.addEventListener('pointerdown', (e) => { e.preventDefault(); fn(e); });
    el.addEventListener('click', (e) => { e.preventDefault(); fn(e); });
  }

  addButtonHandler(btnTurbo, ()=>{ turboEnabled = !turboEnabled; updateButtonLabels(); });
  addButtonHandler(btnMinimap, ()=>{ minimapEnabled = !minimapEnabled; updateButtonLabels(); });
  addButtonHandler(btnPause, ()=>{ paused = !paused; updateButtonLabels(); });
  addButtonHandler(btnReset, ()=>{ player.x = 0; player.y = 0; player.vx = 0; player.vy = 0; player.angle = 0; });

  updateButtonLabels();

  // Stars (reduced and reasonable default)
  const stars = [];
  // To avoid huge allocations on load, cap the initial star count.
  const initialStars = 3000; // tweak this number for performance/visuals
  for (let i = 0; i < initialStars; i++) {
    stars.push({
      x: (Math.random() - 0.5) * worldRadius * 2,
      y: (Math.random() - 0.5) * worldRadius * 2,
      size: Math.random() * 4 + 0.5
    });
  }

  // ============================
  // Sistemas estelares
  // ============================
  const systems = [
    // Sistema Central
    {
      name: "Sistema Central",
      sun: { x: 50000, y: 50000, mass: 2000, radius: 1500, color: "yellow" },
      planets: [
        { name: "Mercúrio", distance: 6000, speed: 0.0003, angle: Math.random()*Math.PI*2, radius: 200, color: "gray", mass: 30 },
        { name: "Vênus", distance: 10000, speed: 0.0002, angle: Math.random()*Math.PI*2, radius: 350, color: "gold", mass: 40 },
        { name: "Terra", distance: 14000, speed: 0.00015, angle: Math.random()*Math.PI*2, radius: 400, color: "blue", mass: 40 },
        { name: "Marte", distance: 18000, speed: 0.00012, angle: Math.random()*Math.PI*2, radius: 300, color: "red", mass: 26 }
      ]
    },
    // ... outros sistemas mantidos (mantive todos do seu original)
    {
      name: "Sistema Boreal",
      sun: { x: 20000, y: 80000, mass: 900, radius: 700, color: "#8FDBFF" },
      planets: [
        { name: "Aurion",  distance: 8000,  speed: 0.00022, angle: Math.random()*Math.PI*2, radius: 300, color: "#00C8FF", mass: 25 },
        { name: "Gelmare", distance: 13000, speed: 0.00018, angle: Math.random()*Math.PI*2, radius: 420, color: "#7FF6FF", mass: 32 },
        { name: "Kryst",   distance: 20000, speed: 0.00010, angle: Math.random()*Math.PI*2, radius: 600, color: "#AFFFFF", mass: 55 }
      ]
    },
    {
      name: "Sistema Rubrum",
      sun: { x: 85000, y: 25000, mass: 600, radius: 500, color: "#FF5C5C" },
      planets: [
        { name: "Scorn", distance: 5000, speed: 0.0003, angle: Math.random()*Math.PI*2, radius: 180, color: "#FF0000", mass: 20 },
        { name: "Balor", distance: 9000, speed: 0.00022, angle: Math.random()*Math.PI*2, radius: 300, color: "#FF7A00", mass: 28 },
        { name: "Vulcar",distance: 15000, speed: 0.00016, angle: Math.random()*Math.PI*2, radius: 450, color: "#FFA200", mass: 40 }
      ]
    },
    {
      name: "Sistema Elyrium",
      sun: { x: 120000, y: 100000, mass: 1200, radius: 950, color: "#D7F1FF" },
      planets: [
        { name: "Shyra",   distance: 9000,  speed: 0.00024, angle: Math.random()*Math.PI*2, radius: 260, color: "#FFF7C0", mass: 24 },
        { name: "Talyon",  distance: 17000, speed: 0.00018, angle: Math.random()*Math.PI*2, radius: 480, color: "#B8FF8E", mass: 45 },
        { name: "Friela",  distance: 26000, speed: 0.00011, angle: Math.random()*Math.PI*2, radius: 700, color: "#A0C5FF", mass: 70 }
      ]
    },
    {
      name: "Sistema Arkan",
      sun: { x: 40000, y: 150000, mass: 800, radius: 600, color: "#FFB469" },
      planets: [
        { name: "Rakef",  distance: 7000,  speed: 0.00027, angle: Math.random()*Math.PI*2, radius: 220, color: "#FF9248", mass: 28 },
        { name: "Domare", distance: 13000, speed: 0.00019, angle: Math.random()*Math.PI*2, radius: 360, color: "#FFE560", mass: 40 },
        { name: "Garon",  distance: 21000, speed: 0.00013, angle: Math.random()*Math.PI*2, radius: 520, color: "#FFD299", mass: 55 }
      ]
    },
    {
      name: "Sistema Colosso",
      sun: { x: 150000, y: 50000, mass: 4000, radius: 3000, color: "#FF6B6B" },
      planets: [
        { name: "Torun",   distance: 16000, speed: 0.00014, angle: Math.random()*Math.PI*2, radius: 600, color: "#FFD000", mass: 85 },
        { name: "Cryon",   distance: 30000, speed: 0.00010, angle: Math.random()*Math.PI*2, radius: 800, color: "#00FFE5", mass: 110 },
        { name: "Velkar",  distance: 45000, speed: 0.00007, angle: Math.random()*Math.PI*2, radius: 950, color: "#7F00FF", mass: 150 }
      ]
    }
  ];

  // Select active system to avoid undefined 'sun' or 'planets'
  let currentSystemIndex = 0;
  let currentSystem = systems[currentSystemIndex];
  let sun = currentSystem.sun;
  let planets = currentSystem.planets;

  function switchSystem(index) {
    if (index < 0 || index >= systems.length) return;
    currentSystemIndex = index;
    currentSystem = systems[currentSystemIndex];
    sun = currentSystem.sun;
    planets = currentSystem.planets;
  }

  // --- JOYSTICK implementation (mobile-only) ---
  const joyArea = document.getElementById("joystick-area");
  const joyStick = document.getElementById("joystick-stick");
  let joyCenter = { x: 0, y: 0, r: 60 };
  let joyActive = false;
  const joystick = { dx: 0, dy: 0, mag: 0 }; // dx,dy normalized (-1..1), mag 0..1

  function updateJoyCenter(){
    const r = joyArea.getBoundingClientRect();
    joyCenter.x = r.left + r.width/2;
    joyCenter.y = r.top + r.height/2;
    // radius for full push
    joyCenter.r = Math.min(r.width, r.height) * 0.38; // ~60
  }
  updateJoyCenter();
  window.addEventListener("resize", updateJoyCenter);

  function getTouchPoint(e) {
    if (e.changedTouches && e.changedTouches.length) return e.changedTouches[0];
    if (e.touches && e.touches.length) return e.touches[0];
    return e;
  }

  function joyStart(e){
    joyActive = true;
    handleJoyMove(e);
  }
  function joyMove(e){
    if(!joyActive) return;
    handleJoyMove(e);
    if (e.preventDefault) e.preventDefault();
  }
  function joyEnd(e){
    joyActive = false;
    joystick.dx = 0; joystick.dy = 0; joystick.mag = 0;
    joyStick.style.transform = `translate(0px,0px)`;
  }

  function handleJoyMove(e){
    const touch = getTouchPoint(e);
    if (!touch) return;
    let x = touch.clientX - joyCenter.x;
    let y = touch.clientY - joyCenter.y;
    const dist = Math.sqrt(x*x + y*y);
    const max = joyCenter.r || 60;
    const clamped = dist > max ? max : dist;
    const nx = x / max;
    const ny = y / max;
    joystick.dx = nx;
    joystick.dy = ny;
    joystick.mag = Math.min(dist / max, 1);

    // move visual knob
    const tx = (clamped * (x / (dist || 1)));
    const ty = (clamped * (y / (dist || 1)));
    joyStick.style.transform = `translate(${tx}px, ${ty}px)`;
  }

  // pointer events fallback for desktop + touch
  joyArea.addEventListener("pointerdown", (e)=>{ joyStart(e); }, {passive:false});
  joyArea.addEventListener("pointermove", (e)=>{ joyMove(e); }, {passive:false});
  joyArea.addEventListener("pointerup", (e)=>{ joyEnd(e); }, {passive:false});
  joyArea.addEventListener("pointercancel", (e)=>{ joyEnd(e); }, {passive:false});

  // Keep original touch handlers as well for older browsers
  joyArea.addEventListener("touchstart", joyStart, {passive:false});
  joyArea.addEventListener("touchmove", joyMove, {passive:false});
  joyArea.addEventListener("touchend", joyEnd, {passive:false});
  joyArea.addEventListener("touchcancel", joyEnd, {passive:false});

  // --- GAME UPDATE (adapted to use joystick for input) ---
  function update() {
    if (paused) return;

    const friction = 0.999;
    const acceleration = turboEnabled ? 2 : 0.5;
    maxSpeed = turboEnabled ? 200 : 50;

    // If joystick pushed, use it to direct & accelerate:
    if (joystick.mag > 0.03) { // small deadzone
      // joystick.dy positive = finger down -> canvas y increases downward
      // We use atan2(dy, dx) because dy is positive downward; that yields angles compatible with canvas coords.
      const dx = joystick.dx;
      const dy = joystick.dy;
      const targetAngle = Math.atan2(dy, dx);
      // Smooth rotation toward target (small smoothing to avoid snap)
      const angDiff = normalizeAngle(targetAngle - player.angle);
      player.angle += angDiff * 0.25; // smoothing factor

      // acceleration proportional to how far joystick is pushed (mag) and to acceleration value
      const thrust = joystick.mag * acceleration;
      player.vx += Math.cos(player.angle) * thrust;
      player.vy += Math.sin(player.angle) * thrust;
    }

    // Limit speed
    let speed = Math.hypot(player.vx, player.vy);
    if (speed > maxSpeed) {
      let scale = maxSpeed / speed;
      player.vx *= scale;
      player.vy *= scale;
    }

    // Gravidade
    const G = 500;
    const applyGravity = (m, x, y) => {
      const dx = x - player.x;
      const dy = y - player.y;
      const distSq = dx * dx + dy * dy;
      const dist = Math.sqrt(distSq);
      if (dist > 20) {
        const force = (G * m) / distSq;
        player.vx += (dx / dist) * force;
        player.vy += (dy / dist) * force;
      }
    };

    // Use sun and planets from currentSystem
    applyGravity(sun.mass, sun.x, sun.y);
    for (let planet of planets) {
      const px = sun.x + planet.distance * Math.cos(planet.angle);
      const py = sun.y + planet.distance * Math.sin(planet.angle);
      applyGravity(planet.mass, px, py);
    }

    // Atualiza posição do jogador
    player.vx *= friction;
    player.vy *= friction;
    player.x += player.vx;
    player.y += player.vy;

    // Colisão com Sol
    const distSun = Math.hypot(player.x - sun.x, player.y - sun.y);
    if (distSun < sun.radius) {
      const angleOut = Math.atan2(player.y - sun.y, player.x - sun.x);
      player.x = sun.x + Math.cos(angleOut) * (sun.radius + 1);
      player.y = sun.y + Math.sin(angleOut) * (sun.radius + 1);
      player.vx = 0;
      player.vy = 0;
    }

    // Colisão e aderência com planetas
    for (let planet of planets) {
      const px = sun.x + planet.distance * Math.cos(planet.angle);
      const py = sun.y + planet.distance * Math.sin(planet.angle);
      const d = Math.hypot(player.x - px, player.y - py);

      if (d < planet.radius) {
        const angleOut = Math.atan2(player.y - py, player.x - px);
        player.x = px + Math.cos(angleOut) * planet.radius;
        player.y = py + Math.sin(angleOut) * planet.radius;

        const orbitalVx = -Math.sin(planet.angle) * planet.speed * planet.distance;
        const orbitalVy = Math.cos(planet.angle) * planet.speed * planet.distance;

        player.vx += (orbitalVx - player.vx) * 0.1;
        player.vy += (orbitalVy - player.vy) * 0.1;

        player.vx *= 0.98;
        player.vy *= 0.98;
      }
    }

    // World borders — pequenos ajustes para evitar teleport repetido
    if (player.x < -worldRadius) {
      player.x = -worldRadius + 1000;
      player.vx *= -1;
    }
    if (player.x > worldRadius) {
      player.x = worldRadius - 1000;
      player.vx *= -1;
    }
    if (player.y < -worldRadius) {
      player.y = -worldRadius + 1000;
      player.vy *= -1;
    }
    if (player.y > worldRadius) {
      player.y = worldRadius - 1000;
      player.vy *= -1;
    }

    // Advance planets angles
    for (let planet of planets) planet.angle += planet.speed;
  }

  // Normalize angle helper
  function normalizeAngle(a){
    while (a > Math.PI) a -= Math.PI * 2;
    while (a < -Math.PI) a += Math.PI * 2;
    return a;
  }

  // --- DRAW (kept original visuals, adjusted for DPR scaling) ---
  function draw() {
    // clear using CSS-sized rect (ctx is scaled to CSS pixels already via setTransform)
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const offsetX = canvas.width / (window.devicePixelRatio || 1) / 2 - player.x;
    const offsetY = canvas.height / (window.devicePixelRatio || 1) / 2 - player.y;

    const gridSpacing = 500;
    ctx.strokeStyle = "#222";
    ctx.lineWidth = 0.5;

    // limited grid around player (for perf)
    const range = 3000;
    const startX = Math.floor((player.x - range) / gridSpacing) * gridSpacing;
    const endX = Math.floor((player.x + range) / gridSpacing) * gridSpacing;
    const startY = Math.floor((player.y - range) / gridSpacing) * gridSpacing;
    const endY = Math.floor((player.y + range) / gridSpacing) * gridSpacing;

    for (let x = startX; x <= endX; x += gridSpacing) {
      ctx.beginPath();
      ctx.moveTo(x + offsetX, 0);
      ctx.lineTo(x + offsetX, canvas.height / (window.devicePixelRatio || 1));
      ctx.stroke();
    }
    for (let y = startY; y <= endY; y += gridSpacing) {
      ctx.beginPath();
      ctx.moveTo(0, y + offsetY);
      ctx.lineTo(canvas.width / (window.devicePixelRatio || 1), y + offsetY);
      ctx.stroke();
    }

    ctx.fillStyle = "white";
    for (let star of stars) {
      const sx = star.x + offsetX;
      const sy = star.y + offsetY;
      if (sx >= -10 && sx <= (canvas.width / (window.devicePixelRatio || 1)) + 10 && sy >= -10 && sy <= (canvas.height / (window.devicePixelRatio || 1)) + 10) {
        ctx.beginPath();
        ctx.arc(sx, sy, star.size, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    ctx.beginPath();
    ctx.arc(sun.x + offsetX, sun.y + offsetY, sun.radius, 0, Math.PI * 2);
    ctx.fillStyle = sun.color || "yellow";
    ctx.fill();

    for (let planet of planets) {
      const x = sun.x + planet.distance * Math.cos(planet.angle);
      const y = sun.y + planet.distance * Math.sin(planet.angle);
      ctx.beginPath();
      ctx.arc(x + offsetX, y + offsetY, planet.radius, 0, Math.PI * 2);
      ctx.fillStyle = planet.color;
      ctx.fill();
    }

    // Ship
    ctx.save();
    ctx.translate(canvas.width / (window.devicePixelRatio || 1) / 2, canvas.height / (window.devicePixelRatio || 1) / 2);
    ctx.rotate(player.angle);
    ctx.fillStyle = "lime";
    ctx.beginPath();
    ctx.moveTo(15, 0);
    ctx.lineTo(-10, -7);
    ctx.lineTo(-10, 7);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    drawBorderEffect();
    drawHUD();
    if (minimapEnabled) drawMinimap();
  }

  function drawBorderEffect() {
    const maxEffectDistance = 1000;

    const distToLeft = player.x + worldRadius;
    const distToRight = worldRadius - player.x;
    const distToTop = player.y + worldRadius;
    const distToBottom = worldRadius - player.y;

    const minDist = Math.min(distToLeft, distToRight, distToTop, distToBottom);

    if (minDist < maxEffectDistance) {
      const opacity = 1 - minDist / maxEffectDistance;
      ctx.fillStyle = `rgba(128, 0, 128, ${Math.max(0, Math.min(1, opacity))})`;
      ctx.fillRect(0, 0, canvas.width / (window.devicePixelRatio || 1),
